<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>gedcom.parser API documentation</title>
<meta name="description" content="Module containing the actual `gedcom.parser.Parser` used to generate elements
out of each line - which can in return be manipulated." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gedcom.parser</code></h1>
</header>
<section id="section-intro">
<p>Module containing the actual <code><a title="gedcom.parser.Parser" href="#gedcom.parser.Parser">Parser</a></code> used to generate elements
out of each line - which can in return be manipulated.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

#  Copyright (C) 2020
#
#  This file is part of the Python GEDCOM Parser.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#  For more, have a look at the GitHub repository at:
#  https://github.com/nickreynke/python-gedcom

&#34;&#34;&#34;
Module containing the actual `gedcom.parser.Parser` used to generate elements
out of each line - which can in return be manipulated.
&#34;&#34;&#34;

import re as regex
from sys import stdout
from sys import version_info
from typing import Tuple, List, IO

import gedcom.tags as tags
import gedcom.standards as standards

from gedcom.detect import get_encoding, get_version
from gedcom.elements.element import Element
from gedcom.elements.header import HeaderElement
from gedcom.elements.family import FamilyElement
from gedcom.elements.individual import IndividualElement
from gedcom.elements.note import NoteElement
from gedcom.elements.object import ObjectElement
from gedcom.elements.source import SourceElement
from gedcom.elements.submission import SubmissionElement
from gedcom.elements.submitter import SubmitterElement
from gedcom.elements.repository import RepositoryElement
from gedcom.elements.root import RootElement

from gedcom.errors import GedcomVersionUnsupportedError
from gedcom.errors import GedcomFormatUnsupportedError
from gedcom.errors import GedcomFormatViolationError
from gedcom.errors import NotAnActualIndividualError
from gedcom.errors import NotAnActualFamilyError

ERROR_TEMPLATE = &#34;Line &lt;{0}:{1}&gt; of document violates GEDCOM format {2}\nSee: {3}&#34;

RECORD_ELEMENTS = {
    tags.GEDCOM_TAG_HEADER: HeaderElement,
    tags.GEDCOM_TAG_INDIVIDUAL: IndividualElement,
    tags.GEDCOM_TAG_FAMILY: FamilyElement,
    tags.GEDCOM_TAG_NOTE: NoteElement,
    tags.GEDCOM_TAG_OBJECT: ObjectElement,
    tags.GEDCOM_TAG_SOURCE: SourceElement,
    tags.GEDCOM_TAG_SUBMISSION: SubmissionElement,
    tags.GEDCOM_TAG_SUBMITTER: SubmitterElement,
    tags.GEDCOM_TAG_REPOSITORY: RepositoryElement
}

FAMILY_MEMBERS_TYPE_ALL = &#34;ALL&#34;
FAMILY_MEMBERS_TYPE_CHILDREN = tags.GEDCOM_TAG_CHILD
FAMILY_MEMBERS_TYPE_HUSBAND = tags.GEDCOM_TAG_HUSBAND
FAMILY_MEMBERS_TYPE_PARENTS = &#34;PARENTS&#34;
FAMILY_MEMBERS_TYPE_WIFE = tags.GEDCOM_TAG_WIFE


class Parser():
    &#34;&#34;&#34;Parses and manipulates GEDCOM formatted data.

    For documentation of the different GEDCOM standards see the
    links defined in `gedcom.standards`

    This parser reads and parses a GEDCOM file.

    Elements may be accessed via:

    * a `list` through `gedcom.parser.Parser.get_element_list()`
    * a `dict` through `gedcom.parser.Parser.get_element_dictionary()`
    &#34;&#34;&#34;

    def __init__(self):
        self.__element_list = []
        self.__element_dictionary = {}
        self.__root_element = RootElement()

    def invalidate_cache(self):
        &#34;&#34;&#34;Empties the element list and dictionary to cause
        `gedcom.parser.Parser.get_element_list()` and
        `gedcom.parser.Parser.get_element_dictionary()` to return updated data.

        The update gets deferred until each of the methods actually gets called.
        &#34;&#34;&#34;
        self.__element_list = []
        self.__element_dictionary = {}

    def get_element_list(self) -&gt; List[Element]:
        &#34;&#34;&#34;Returns a list containing all elements from within the GEDCOM file.

        By default elements are in the same order as they appeared in the file.

        This list gets generated on-the-fly, but gets cached. If the database
        was modified, you should call `gedcom.parser.Parser.invalidate_cache()` once
        to let this method return updated data.

        Consider using `gedcom.parser.Parser.get_root_element()` or
        `gedcom.parser.Parser.get_root_child_elements()` to access
        the hierarchical GEDCOM tree, unless you rarely modify the database.
        &#34;&#34;&#34;
        if not self.__element_list:
            for element in self.get_root_child_elements():
                self.__build_list(element, self.__element_list)
        return self.__element_list

    def get_element_dictionary(self) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary containing all elements, identified by a pointer,
        from within the GEDCOM file.

        Only elements identified by a pointer are listed in the dictionary.
        The keys for the dictionary are the pointers.

        This dictionary gets generated on-the-fly, but gets cached. If the
        database was modified, you should call `invalidate_cache()` once to let
        this method return updated data.
        &#34;&#34;&#34;
        if not self.__element_dictionary:
            self.__element_dictionary = {
                element.get_pointer():
                element for element in self.get_root_child_elements() if element.get_pointer()
            }

        return self.__element_dictionary

    def get_root_element(self) -&gt; RootElement:
        &#34;&#34;&#34;Returns a virtual root element containing all logical records as children.

        When printed, this element converts to an empty string.
        &#34;&#34;&#34;
        return self.__root_element

    def get_root_child_elements(self) -&gt; List[Element]:
        &#34;&#34;&#34;Returns a list of logical records in the GEDCOM file.

        By default, elements are in the same order as they appeared in the file.
        &#34;&#34;&#34;
        return self.get_root_element().get_child_elements()

    def parse_file(self, file_path: str, strict: bool = True):
        &#34;&#34;&#34;Opens and parses a file, from the given file path, as GEDCOM formatted data.
        &#34;&#34;&#34;
        codec = get_encoding(file_path)
        real_version, reported_version, reported_format = get_version(file_path, codec)

        if reported_version == &#39;5.5.5&#39;:
            errmsg = &#34;This parser does not properly support the GEDCOM &#34; + reported_version + \
                &#34; standard at this time\nSee: {0}&#34;.format(standards.GEDCOM_5_5_5)
            raise GedcomVersionUnsupportedError(errmsg)

        if reported_format not in [&#39;LINEAGE-LINKED&#39;, &#39;LINEAGE_LINKED&#39;,
                                   &#39;LINAGE-LINKED&#39;, &#39;Lineage - Linked&#39;]:
            errmsg = &#34;This parser does not recognize the GEDCOM format &#34; + reported_format + \
                &#34; at this time\nSee: {0}&#34;.format(standards.GEDCOM_5_5_5)
            raise GedcomFormatUnsupportedError(errmsg)

        with open(file_path, &#39;r&#39;, encoding=codec) as gedcom_stream:
            self.parse(gedcom_stream, strict)

    def parse(self, gedcom_stream: IO, strict: bool = True):
        &#34;&#34;&#34;Parses a stream, or an array of lines, as GEDCOM formatted data.
        &#34;&#34;&#34;
        self.invalidate_cache()
        self.__root_element = RootElement()

        line_number = 1
        last_element = self.get_root_element()

        for line in gedcom_stream:
            last_element = self.__parse_line(line_number, line, last_element, strict)
            line_number += 1

    # Private methods

    @staticmethod
    def __parse_line(line_number: int, line: str, last_element: Element,
                     strict: bool = True) -&gt; Element:
        &#34;&#34;&#34;Parse a line from a GEDCOM formatted document.

        Each line should have the following (bracketed items optional):
        level + &#39; &#39; + [pointer + &#39; &#39; +] tag + [&#39; &#39; + line_value]
        &#34;&#34;&#34;

        # Level must start with non-negative int, no leading zeros.
        level_regex = &#39;^(0|[1-9]+[0-9]*) &#39;

        # Pointer optional, if it exists it must be flanked by `@`
        pointer_regex = &#39;(@[^@]+@ |)&#39;

        # Tag must be an alphanumeric string
        tag_regex = &#39;([A-Za-z0-9_]+)&#39;

        # Value optional, consists of anything after a space to end of line
        value_regex = &#39;( [^\n\r]*|)&#39;

        # End of line defined by `\n` or `\r`
        end_of_line_regex = &#39;([\r\n]{1,2})&#39;

        # Complete regex
        gedcom_line_regex = level_regex + pointer_regex + tag_regex + \
            value_regex + end_of_line_regex
        regex_match = regex.match(gedcom_line_regex, line)

        if regex_match is None:
            if strict:
                errmsg = ERROR_TEMPLATE.format(line_number, line, &#39;5.5.1&#39;, standards.GEDCOM_5_5_1)
                raise GedcomFormatViolationError(errmsg)

            # Quirk check - see if this is a line without a CRLF (which could be the last line)
            last_line_regex = level_regex + pointer_regex + tag_regex + value_regex
            regex_match = regex.match(last_line_regex, line)
            if regex_match is not None:
                line_parts = regex_match.groups()

                level = int(line_parts[0])
                pointer = line_parts[1].rstrip(&#39; &#39;)
                tag = line_parts[2]
                value = line_parts[3][1:]
                crlf = &#39;\n&#39;
            else:
                # Quirk check - Sometimes a gedcom has a text field with a CR.
                # This creates a line without the standard level and pointer.
                # If this is detected then turn it into a CONC or CONT.
                line_regex = &#39;([^\n\r]*|)&#39;
                cont_line_regex = line_regex + end_of_line_regex
                regex_match = regex.match(cont_line_regex, line)
                line_parts = regex_match.groups()
                level = last_element.get_level()
                tag = last_element.get_tag()
                pointer = None
                value = line_parts[0][1:]
                crlf = line_parts[1]
                if tag not in [tags.GEDCOM_TAG_CONTINUED, tags.GEDCOM_TAG_CONCATENATION]:
                    # Increment level and change this line to a CONC
                    level += 1
                    tag = tags.GEDCOM_TAG_CONCATENATION
        else:
            line_parts = regex_match.groups()

            level = int(line_parts[0])
            pointer = line_parts[1].rstrip(&#39; &#39;)
            tag = line_parts[2]
            value = line_parts[3][1:]
            crlf = line_parts[4]

        # Check level: should never be more than one higher than previous line.
        if level &gt; last_element.get_level() + 1:
            errmsg = &#34;Line {0} of document violates GEDCOM format 5.5.1\n&#34;.format(line_number) + \
                &#34;Lines must be no more than one level higher than previous line.\n&#34; + \
                &#34;See: {0}&#34;.format(standards.GEDCOM_5_5_1)
            raise GedcomFormatViolationError(errmsg)

        # Create element. Store in list and dict, create children and parents.
        if tag in RECORD_ELEMENTS:
            element = RECORD_ELEMENTS[tag](level, pointer, tag, value, crlf, multi_line=False)
        else:
            element = Element(level, pointer, tag, value, crlf, multi_line=False)

        # Start with last element as parent, back up if necessary.
        parent_element = last_element

        while parent_element.get_level() &gt; level - 1:
            parent_element = parent_element.get_parent_element()

        # Add child to parent &amp; parent to child.
        parent_element.add_child_element(element)

        return element

    def __build_list(self, element: Element, element_list: List[Element]):
        &#34;&#34;&#34;Recursively add elements to a list containing elements.
        &#34;&#34;&#34;
        element_list.append(element)
        for child in element.get_child_elements():
            self.__build_list(child, element_list)

    # Methods for analyzing individuals and relationships between individuals

    def get_marriages(self, individual: IndividualElement) -&gt; Tuple[str, str]:
        &#34;&#34;&#34;Returns a list of marriages of an individual formatted as a tuple:
        (`str` date, `str` place)
        &#34;&#34;&#34;
        marriages = []
        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )
        # Get and analyze families where individual is spouse.
        families = self.get_families(individual, tags.GEDCOM_TAG_FAMILY_SPOUSE)
        for family in families:
            for family_data in family.get_child_elements():
                if family_data.get_tag() == tags.GEDCOM_TAG_MARRIAGE:
                    date = &#39;&#39;
                    place = &#39;&#39;
                    for marriage_data in family_data.get_child_elements():
                        if marriage_data.get_tag() == tags.GEDCOM_TAG_DATE:
                            date = marriage_data.get_value()
                        if marriage_data.get_tag() == tags.GEDCOM_TAG_PLACE:
                            place = marriage_data.get_value()
                    marriages.append((date, place))
        return marriages

    def get_marriage_years(self, individual: IndividualElement) -&gt; List[int]:
        &#34;&#34;&#34;Returns a list of marriage years for an individual.
        &#34;&#34;&#34;
        dates = []

        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        # Get and analyze families where individual is spouse.
        families = self.get_families(individual, tags.GEDCOM_TAG_FAMILY_SPOUSE)
        for family in families:
            for child in family.get_child_elements():
                if child.get_tag() == tags.GEDCOM_TAG_MARRIAGE:
                    for gchild in child.get_child_elements():
                        if gchild.get_tag() == tags.GEDCOM_TAG_DATE:
                            date = gchild.get_value().split()[-1]
                            try:
                                dates.append(int(date))
                            except ValueError:
                                pass
        return dates

    def marriage_year_match(self, individual: IndividualElement, year: int) -&gt; bool:
        &#34;&#34;&#34;Checks if one of the marriage years of an individual matches the supplied year.
        Year is an integer.
        &#34;&#34;&#34;
        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        years = self.get_marriage_years(individual)
        return year in years

    def marriage_range_match(self, individual: IndividualElement,
                             from_year: int, to_year: int) -&gt; bool:
        &#34;&#34;&#34;Check if one of the marriage years of an individual is in a given range.
        Years are integers.
        &#34;&#34;&#34;
        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        years = self.get_marriage_years(individual)
        for year in years:
            if from_year &lt;= year &lt;= to_year:
                return True
        return False

    def get_families(self, individual: IndividualElement,
                     family_type: str = tags.GEDCOM_TAG_FAMILY_SPOUSE) -&gt; List[FamilyElement]:
        &#34;&#34;&#34;Return family elements listed for an individual.

        Optional argument `family_type` can be used to return specific subsets:

        `tags.GEDCOM_TAG_FAMILY_SPOUSE`: Default, families where the individual is a spouse.

        `tags.GEDCOM_TAG_FAMILY_CHILD`: Families where the individual is a child.
        &#34;&#34;&#34;
        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        families = []
        element_dictionary = self.get_element_dictionary()

        for child_element in individual.get_child_elements():
            is_family = (child_element.get_tag() == family_type
                         and child_element.get_value() in element_dictionary
                         and element_dictionary[child_element.get_value()].is_family())
            if is_family:
                families.append(element_dictionary[child_element.get_value()])

        return families

    def get_ancestors(self, individual: IndividualElement,
                      ancestor_type: str = &#34;ALL&#34;) -&gt; List[Element]:
        &#34;&#34;&#34;Return elements corresponding to ancestors of an individual.

        Optional argument `ancestor_type` can be used to return specific subsets:

        &#34;ALL&#34;: Default, returns all ancestors.

        &#34;NAT&#34;: Return only natural (genetic) ancestors.
        &#34;&#34;&#34;
        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        parents = self.get_parents(individual, ancestor_type)
        ancestors = []
        ancestors.extend(parents)

        for parent in parents:
            ancestors.extend(self.get_ancestors(parent))

        return ancestors

    def get_parents(self, individual: IndividualElement,
                    parent_type: str = &#34;ALL&#34;) -&gt; List[IndividualElement]:
        &#34;&#34;&#34;Return elements corresponding to parents of an individual.

        Optional argument `parent_type` can be used to return specific subsets:

        &#34;ALL&#34;: Default, returns all parents.

        &#34;NAT&#34;: Return only natural (genetic) parents.
        &#34;&#34;&#34;
        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        parents = []
        families = self.get_families(individual, tags.GEDCOM_TAG_FAMILY_CHILD)

        for family in families:
            if parent_type == &#34;NAT&#34;:
                for family_member in family.get_child_elements():

                    if family_member.get_tag() == tags.GEDCOM_TAG_CHILD \
                            and family_member.get_value() == individual.get_pointer():

                        for child in family_member.get_child_elements():
                            if child.get_value() == &#34;Natural&#34;:
                                if child.get_tag() == tags.GEDCOM_PROGRAM_DEFINED_TAG_MREL:
                                    parents += self.get_family_members(family,
                                                                       tags.GEDCOM_TAG_WIFE)
                                elif child.get_tag() == tags.GEDCOM_PROGRAM_DEFINED_TAG_FREL:
                                    parents += self.get_family_members(family,
                                                                       tags.GEDCOM_TAG_HUSBAND)
            else:
                parents += self.get_family_members(family, &#34;PARENTS&#34;)

        return parents

    def find_path_to_ancestor(self, descendant: IndividualElement,
                              ancestor: IndividualElement, path: str = None):
        &#34;&#34;&#34;Return path from descendant to ancestor.
        :rtype: object
        &#34;&#34;&#34;
        if not isinstance(descendant, IndividualElement) and isinstance(ancestor,
                                                                        IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag.&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        if not path:
            path = [descendant]

        if path[-1].get_pointer() == ancestor.get_pointer():
            return path

        parents = self.get_parents(descendant, &#34;NAT&#34;)
        for parent in parents:
            potential_path = self.find_path_to_ancestor(parent, ancestor, path + [parent])
            if potential_path is not None:
                return potential_path

        return None

    def get_family_members(self, family: FamilyElement,
                           members_type: str = FAMILY_MEMBERS_TYPE_ALL) -&gt; List[IndividualElement]:
        &#34;&#34;&#34;Return array of family members: individual, spouse, and children.

        Optional argument `members_type` can be used to return specific subsets:

        &#34;FAMILY_MEMBERS_TYPE_ALL&#34;: Default, return all members of the family

        &#34;FAMILY_MEMBERS_TYPE_PARENTS&#34;: Return individuals with &#34;HUSB&#34; and &#34;WIFE&#34; tags (parents)

        &#34;FAMILY_MEMBERS_TYPE_HUSBAND&#34;: Return individuals with &#34;HUSB&#34; tags (father)

        &#34;FAMILY_MEMBERS_TYPE_WIFE&#34;: Return individuals with &#34;WIFE&#34; tags (mother)

        &#34;FAMILY_MEMBERS_TYPE_CHILDREN&#34;: Return individuals with &#34;CHIL&#34; tags (children)
        &#34;&#34;&#34;
        if not isinstance(family, FamilyElement):
            raise NotAnActualFamilyError(
                &#34;Operation only valid for element with %s tag.&#34; % tags.GEDCOM_TAG_FAMILY
            )

        family_members = []
        element_dictionary = self.get_element_dictionary()

        for child_element in family.get_child_elements():
            # Default is ALL
            is_family = (child_element.get_tag() == tags.GEDCOM_TAG_HUSBAND
                         or child_element.get_tag() == tags.GEDCOM_TAG_WIFE
                         or child_element.get_tag() == tags.GEDCOM_TAG_CHILD)

            if members_type == FAMILY_MEMBERS_TYPE_PARENTS:
                is_family = (child_element.get_tag() == tags.GEDCOM_TAG_HUSBAND
                             or child_element.get_tag() == tags.GEDCOM_TAG_WIFE)
            elif members_type == FAMILY_MEMBERS_TYPE_HUSBAND:
                is_family = child_element.get_tag() == tags.GEDCOM_TAG_HUSBAND
            elif members_type == FAMILY_MEMBERS_TYPE_WIFE:
                is_family = child_element.get_tag() == tags.GEDCOM_TAG_WIFE
            elif members_type == FAMILY_MEMBERS_TYPE_CHILDREN:
                is_family = child_element.get_tag() == tags.GEDCOM_TAG_CHILD

            if is_family and child_element.get_value() in element_dictionary:
                family_members.append(element_dictionary[child_element.get_value()])

        return family_members

    # Other methods

    def to_gedcom_string(self, recursive: bool = False) -&gt; str:
        &#34;&#34;&#34;Formats all elements and optionally all of the sub-elements into a
        GEDCOM string.
        &#34;&#34;&#34;
        is_gte_python_3 = version_info[0] &gt;= 3
        output = &#39;&#39; if is_gte_python_3 else b&#39;&#39;

        for element in self.get_root_child_elements():
            if is_gte_python_3:
                output += element.to_gedcom_string(recursive)
            else:
                output += element.to_gedcom_string(recursive).encode(&#39;utf-8-sig&#39;)

        return output

    def print_gedcom(self):
        &#34;&#34;&#34;Write GEDCOM data to stdout.&#34;&#34;&#34;
        self.save_gedcom(stdout)

    def save_gedcom(self, open_file: IO, recursive: bool = True):
        &#34;&#34;&#34;Save GEDCOM data to a file.
        &#34;&#34;&#34;
        open_file.write(self.to_gedcom_string(recursive))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gedcom.parser.Parser"><code class="flex name class">
<span>class <span class="ident">Parser</span></span>
</code></dt>
<dd>
<div class="desc"><p>Parses and manipulates GEDCOM formatted data.</p>
<p>For documentation of the different GEDCOM standards see the
links defined in <code><a title="gedcom.standards" href="standards.html">gedcom.standards</a></code></p>
<p>This parser reads and parses a GEDCOM file.</p>
<p>Elements may be accessed via:</p>
<ul>
<li>a <code>list</code> through <code><a title="gedcom.parser.Parser.get_element_list" href="#gedcom.parser.Parser.get_element_list">Parser.get_element_list()</a></code></li>
<li>a <code>dict</code> through <code><a title="gedcom.parser.Parser.get_element_dictionary" href="#gedcom.parser.Parser.get_element_dictionary">Parser.get_element_dictionary()</a></code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parser():
    &#34;&#34;&#34;Parses and manipulates GEDCOM formatted data.

    For documentation of the different GEDCOM standards see the
    links defined in `gedcom.standards`

    This parser reads and parses a GEDCOM file.

    Elements may be accessed via:

    * a `list` through `gedcom.parser.Parser.get_element_list()`
    * a `dict` through `gedcom.parser.Parser.get_element_dictionary()`
    &#34;&#34;&#34;

    def __init__(self):
        self.__element_list = []
        self.__element_dictionary = {}
        self.__root_element = RootElement()

    def invalidate_cache(self):
        &#34;&#34;&#34;Empties the element list and dictionary to cause
        `gedcom.parser.Parser.get_element_list()` and
        `gedcom.parser.Parser.get_element_dictionary()` to return updated data.

        The update gets deferred until each of the methods actually gets called.
        &#34;&#34;&#34;
        self.__element_list = []
        self.__element_dictionary = {}

    def get_element_list(self) -&gt; List[Element]:
        &#34;&#34;&#34;Returns a list containing all elements from within the GEDCOM file.

        By default elements are in the same order as they appeared in the file.

        This list gets generated on-the-fly, but gets cached. If the database
        was modified, you should call `gedcom.parser.Parser.invalidate_cache()` once
        to let this method return updated data.

        Consider using `gedcom.parser.Parser.get_root_element()` or
        `gedcom.parser.Parser.get_root_child_elements()` to access
        the hierarchical GEDCOM tree, unless you rarely modify the database.
        &#34;&#34;&#34;
        if not self.__element_list:
            for element in self.get_root_child_elements():
                self.__build_list(element, self.__element_list)
        return self.__element_list

    def get_element_dictionary(self) -&gt; dict:
        &#34;&#34;&#34;Returns a dictionary containing all elements, identified by a pointer,
        from within the GEDCOM file.

        Only elements identified by a pointer are listed in the dictionary.
        The keys for the dictionary are the pointers.

        This dictionary gets generated on-the-fly, but gets cached. If the
        database was modified, you should call `invalidate_cache()` once to let
        this method return updated data.
        &#34;&#34;&#34;
        if not self.__element_dictionary:
            self.__element_dictionary = {
                element.get_pointer():
                element for element in self.get_root_child_elements() if element.get_pointer()
            }

        return self.__element_dictionary

    def get_root_element(self) -&gt; RootElement:
        &#34;&#34;&#34;Returns a virtual root element containing all logical records as children.

        When printed, this element converts to an empty string.
        &#34;&#34;&#34;
        return self.__root_element

    def get_root_child_elements(self) -&gt; List[Element]:
        &#34;&#34;&#34;Returns a list of logical records in the GEDCOM file.

        By default, elements are in the same order as they appeared in the file.
        &#34;&#34;&#34;
        return self.get_root_element().get_child_elements()

    def parse_file(self, file_path: str, strict: bool = True):
        &#34;&#34;&#34;Opens and parses a file, from the given file path, as GEDCOM formatted data.
        &#34;&#34;&#34;
        codec = get_encoding(file_path)
        real_version, reported_version, reported_format = get_version(file_path, codec)

        if reported_version == &#39;5.5.5&#39;:
            errmsg = &#34;This parser does not properly support the GEDCOM &#34; + reported_version + \
                &#34; standard at this time\nSee: {0}&#34;.format(standards.GEDCOM_5_5_5)
            raise GedcomVersionUnsupportedError(errmsg)

        if reported_format not in [&#39;LINEAGE-LINKED&#39;, &#39;LINEAGE_LINKED&#39;,
                                   &#39;LINAGE-LINKED&#39;, &#39;Lineage - Linked&#39;]:
            errmsg = &#34;This parser does not recognize the GEDCOM format &#34; + reported_format + \
                &#34; at this time\nSee: {0}&#34;.format(standards.GEDCOM_5_5_5)
            raise GedcomFormatUnsupportedError(errmsg)

        with open(file_path, &#39;r&#39;, encoding=codec) as gedcom_stream:
            self.parse(gedcom_stream, strict)

    def parse(self, gedcom_stream: IO, strict: bool = True):
        &#34;&#34;&#34;Parses a stream, or an array of lines, as GEDCOM formatted data.
        &#34;&#34;&#34;
        self.invalidate_cache()
        self.__root_element = RootElement()

        line_number = 1
        last_element = self.get_root_element()

        for line in gedcom_stream:
            last_element = self.__parse_line(line_number, line, last_element, strict)
            line_number += 1

    # Private methods

    @staticmethod
    def __parse_line(line_number: int, line: str, last_element: Element,
                     strict: bool = True) -&gt; Element:
        &#34;&#34;&#34;Parse a line from a GEDCOM formatted document.

        Each line should have the following (bracketed items optional):
        level + &#39; &#39; + [pointer + &#39; &#39; +] tag + [&#39; &#39; + line_value]
        &#34;&#34;&#34;

        # Level must start with non-negative int, no leading zeros.
        level_regex = &#39;^(0|[1-9]+[0-9]*) &#39;

        # Pointer optional, if it exists it must be flanked by `@`
        pointer_regex = &#39;(@[^@]+@ |)&#39;

        # Tag must be an alphanumeric string
        tag_regex = &#39;([A-Za-z0-9_]+)&#39;

        # Value optional, consists of anything after a space to end of line
        value_regex = &#39;( [^\n\r]*|)&#39;

        # End of line defined by `\n` or `\r`
        end_of_line_regex = &#39;([\r\n]{1,2})&#39;

        # Complete regex
        gedcom_line_regex = level_regex + pointer_regex + tag_regex + \
            value_regex + end_of_line_regex
        regex_match = regex.match(gedcom_line_regex, line)

        if regex_match is None:
            if strict:
                errmsg = ERROR_TEMPLATE.format(line_number, line, &#39;5.5.1&#39;, standards.GEDCOM_5_5_1)
                raise GedcomFormatViolationError(errmsg)

            # Quirk check - see if this is a line without a CRLF (which could be the last line)
            last_line_regex = level_regex + pointer_regex + tag_regex + value_regex
            regex_match = regex.match(last_line_regex, line)
            if regex_match is not None:
                line_parts = regex_match.groups()

                level = int(line_parts[0])
                pointer = line_parts[1].rstrip(&#39; &#39;)
                tag = line_parts[2]
                value = line_parts[3][1:]
                crlf = &#39;\n&#39;
            else:
                # Quirk check - Sometimes a gedcom has a text field with a CR.
                # This creates a line without the standard level and pointer.
                # If this is detected then turn it into a CONC or CONT.
                line_regex = &#39;([^\n\r]*|)&#39;
                cont_line_regex = line_regex + end_of_line_regex
                regex_match = regex.match(cont_line_regex, line)
                line_parts = regex_match.groups()
                level = last_element.get_level()
                tag = last_element.get_tag()
                pointer = None
                value = line_parts[0][1:]
                crlf = line_parts[1]
                if tag not in [tags.GEDCOM_TAG_CONTINUED, tags.GEDCOM_TAG_CONCATENATION]:
                    # Increment level and change this line to a CONC
                    level += 1
                    tag = tags.GEDCOM_TAG_CONCATENATION
        else:
            line_parts = regex_match.groups()

            level = int(line_parts[0])
            pointer = line_parts[1].rstrip(&#39; &#39;)
            tag = line_parts[2]
            value = line_parts[3][1:]
            crlf = line_parts[4]

        # Check level: should never be more than one higher than previous line.
        if level &gt; last_element.get_level() + 1:
            errmsg = &#34;Line {0} of document violates GEDCOM format 5.5.1\n&#34;.format(line_number) + \
                &#34;Lines must be no more than one level higher than previous line.\n&#34; + \
                &#34;See: {0}&#34;.format(standards.GEDCOM_5_5_1)
            raise GedcomFormatViolationError(errmsg)

        # Create element. Store in list and dict, create children and parents.
        if tag in RECORD_ELEMENTS:
            element = RECORD_ELEMENTS[tag](level, pointer, tag, value, crlf, multi_line=False)
        else:
            element = Element(level, pointer, tag, value, crlf, multi_line=False)

        # Start with last element as parent, back up if necessary.
        parent_element = last_element

        while parent_element.get_level() &gt; level - 1:
            parent_element = parent_element.get_parent_element()

        # Add child to parent &amp; parent to child.
        parent_element.add_child_element(element)

        return element

    def __build_list(self, element: Element, element_list: List[Element]):
        &#34;&#34;&#34;Recursively add elements to a list containing elements.
        &#34;&#34;&#34;
        element_list.append(element)
        for child in element.get_child_elements():
            self.__build_list(child, element_list)

    # Methods for analyzing individuals and relationships between individuals

    def get_marriages(self, individual: IndividualElement) -&gt; Tuple[str, str]:
        &#34;&#34;&#34;Returns a list of marriages of an individual formatted as a tuple:
        (`str` date, `str` place)
        &#34;&#34;&#34;
        marriages = []
        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )
        # Get and analyze families where individual is spouse.
        families = self.get_families(individual, tags.GEDCOM_TAG_FAMILY_SPOUSE)
        for family in families:
            for family_data in family.get_child_elements():
                if family_data.get_tag() == tags.GEDCOM_TAG_MARRIAGE:
                    date = &#39;&#39;
                    place = &#39;&#39;
                    for marriage_data in family_data.get_child_elements():
                        if marriage_data.get_tag() == tags.GEDCOM_TAG_DATE:
                            date = marriage_data.get_value()
                        if marriage_data.get_tag() == tags.GEDCOM_TAG_PLACE:
                            place = marriage_data.get_value()
                    marriages.append((date, place))
        return marriages

    def get_marriage_years(self, individual: IndividualElement) -&gt; List[int]:
        &#34;&#34;&#34;Returns a list of marriage years for an individual.
        &#34;&#34;&#34;
        dates = []

        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        # Get and analyze families where individual is spouse.
        families = self.get_families(individual, tags.GEDCOM_TAG_FAMILY_SPOUSE)
        for family in families:
            for child in family.get_child_elements():
                if child.get_tag() == tags.GEDCOM_TAG_MARRIAGE:
                    for gchild in child.get_child_elements():
                        if gchild.get_tag() == tags.GEDCOM_TAG_DATE:
                            date = gchild.get_value().split()[-1]
                            try:
                                dates.append(int(date))
                            except ValueError:
                                pass
        return dates

    def marriage_year_match(self, individual: IndividualElement, year: int) -&gt; bool:
        &#34;&#34;&#34;Checks if one of the marriage years of an individual matches the supplied year.
        Year is an integer.
        &#34;&#34;&#34;
        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        years = self.get_marriage_years(individual)
        return year in years

    def marriage_range_match(self, individual: IndividualElement,
                             from_year: int, to_year: int) -&gt; bool:
        &#34;&#34;&#34;Check if one of the marriage years of an individual is in a given range.
        Years are integers.
        &#34;&#34;&#34;
        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        years = self.get_marriage_years(individual)
        for year in years:
            if from_year &lt;= year &lt;= to_year:
                return True
        return False

    def get_families(self, individual: IndividualElement,
                     family_type: str = tags.GEDCOM_TAG_FAMILY_SPOUSE) -&gt; List[FamilyElement]:
        &#34;&#34;&#34;Return family elements listed for an individual.

        Optional argument `family_type` can be used to return specific subsets:

        `tags.GEDCOM_TAG_FAMILY_SPOUSE`: Default, families where the individual is a spouse.

        `tags.GEDCOM_TAG_FAMILY_CHILD`: Families where the individual is a child.
        &#34;&#34;&#34;
        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        families = []
        element_dictionary = self.get_element_dictionary()

        for child_element in individual.get_child_elements():
            is_family = (child_element.get_tag() == family_type
                         and child_element.get_value() in element_dictionary
                         and element_dictionary[child_element.get_value()].is_family())
            if is_family:
                families.append(element_dictionary[child_element.get_value()])

        return families

    def get_ancestors(self, individual: IndividualElement,
                      ancestor_type: str = &#34;ALL&#34;) -&gt; List[Element]:
        &#34;&#34;&#34;Return elements corresponding to ancestors of an individual.

        Optional argument `ancestor_type` can be used to return specific subsets:

        &#34;ALL&#34;: Default, returns all ancestors.

        &#34;NAT&#34;: Return only natural (genetic) ancestors.
        &#34;&#34;&#34;
        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        parents = self.get_parents(individual, ancestor_type)
        ancestors = []
        ancestors.extend(parents)

        for parent in parents:
            ancestors.extend(self.get_ancestors(parent))

        return ancestors

    def get_parents(self, individual: IndividualElement,
                    parent_type: str = &#34;ALL&#34;) -&gt; List[IndividualElement]:
        &#34;&#34;&#34;Return elements corresponding to parents of an individual.

        Optional argument `parent_type` can be used to return specific subsets:

        &#34;ALL&#34;: Default, returns all parents.

        &#34;NAT&#34;: Return only natural (genetic) parents.
        &#34;&#34;&#34;
        if not isinstance(individual, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        parents = []
        families = self.get_families(individual, tags.GEDCOM_TAG_FAMILY_CHILD)

        for family in families:
            if parent_type == &#34;NAT&#34;:
                for family_member in family.get_child_elements():

                    if family_member.get_tag() == tags.GEDCOM_TAG_CHILD \
                            and family_member.get_value() == individual.get_pointer():

                        for child in family_member.get_child_elements():
                            if child.get_value() == &#34;Natural&#34;:
                                if child.get_tag() == tags.GEDCOM_PROGRAM_DEFINED_TAG_MREL:
                                    parents += self.get_family_members(family,
                                                                       tags.GEDCOM_TAG_WIFE)
                                elif child.get_tag() == tags.GEDCOM_PROGRAM_DEFINED_TAG_FREL:
                                    parents += self.get_family_members(family,
                                                                       tags.GEDCOM_TAG_HUSBAND)
            else:
                parents += self.get_family_members(family, &#34;PARENTS&#34;)

        return parents

    def find_path_to_ancestor(self, descendant: IndividualElement,
                              ancestor: IndividualElement, path: str = None):
        &#34;&#34;&#34;Return path from descendant to ancestor.
        :rtype: object
        &#34;&#34;&#34;
        if not isinstance(descendant, IndividualElement) and isinstance(ancestor,
                                                                        IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag.&#34; % tags.GEDCOM_TAG_INDIVIDUAL
            )

        if not path:
            path = [descendant]

        if path[-1].get_pointer() == ancestor.get_pointer():
            return path

        parents = self.get_parents(descendant, &#34;NAT&#34;)
        for parent in parents:
            potential_path = self.find_path_to_ancestor(parent, ancestor, path + [parent])
            if potential_path is not None:
                return potential_path

        return None

    def get_family_members(self, family: FamilyElement,
                           members_type: str = FAMILY_MEMBERS_TYPE_ALL) -&gt; List[IndividualElement]:
        &#34;&#34;&#34;Return array of family members: individual, spouse, and children.

        Optional argument `members_type` can be used to return specific subsets:

        &#34;FAMILY_MEMBERS_TYPE_ALL&#34;: Default, return all members of the family

        &#34;FAMILY_MEMBERS_TYPE_PARENTS&#34;: Return individuals with &#34;HUSB&#34; and &#34;WIFE&#34; tags (parents)

        &#34;FAMILY_MEMBERS_TYPE_HUSBAND&#34;: Return individuals with &#34;HUSB&#34; tags (father)

        &#34;FAMILY_MEMBERS_TYPE_WIFE&#34;: Return individuals with &#34;WIFE&#34; tags (mother)

        &#34;FAMILY_MEMBERS_TYPE_CHILDREN&#34;: Return individuals with &#34;CHIL&#34; tags (children)
        &#34;&#34;&#34;
        if not isinstance(family, FamilyElement):
            raise NotAnActualFamilyError(
                &#34;Operation only valid for element with %s tag.&#34; % tags.GEDCOM_TAG_FAMILY
            )

        family_members = []
        element_dictionary = self.get_element_dictionary()

        for child_element in family.get_child_elements():
            # Default is ALL
            is_family = (child_element.get_tag() == tags.GEDCOM_TAG_HUSBAND
                         or child_element.get_tag() == tags.GEDCOM_TAG_WIFE
                         or child_element.get_tag() == tags.GEDCOM_TAG_CHILD)

            if members_type == FAMILY_MEMBERS_TYPE_PARENTS:
                is_family = (child_element.get_tag() == tags.GEDCOM_TAG_HUSBAND
                             or child_element.get_tag() == tags.GEDCOM_TAG_WIFE)
            elif members_type == FAMILY_MEMBERS_TYPE_HUSBAND:
                is_family = child_element.get_tag() == tags.GEDCOM_TAG_HUSBAND
            elif members_type == FAMILY_MEMBERS_TYPE_WIFE:
                is_family = child_element.get_tag() == tags.GEDCOM_TAG_WIFE
            elif members_type == FAMILY_MEMBERS_TYPE_CHILDREN:
                is_family = child_element.get_tag() == tags.GEDCOM_TAG_CHILD

            if is_family and child_element.get_value() in element_dictionary:
                family_members.append(element_dictionary[child_element.get_value()])

        return family_members

    # Other methods

    def to_gedcom_string(self, recursive: bool = False) -&gt; str:
        &#34;&#34;&#34;Formats all elements and optionally all of the sub-elements into a
        GEDCOM string.
        &#34;&#34;&#34;
        is_gte_python_3 = version_info[0] &gt;= 3
        output = &#39;&#39; if is_gte_python_3 else b&#39;&#39;

        for element in self.get_root_child_elements():
            if is_gte_python_3:
                output += element.to_gedcom_string(recursive)
            else:
                output += element.to_gedcom_string(recursive).encode(&#39;utf-8-sig&#39;)

        return output

    def print_gedcom(self):
        &#34;&#34;&#34;Write GEDCOM data to stdout.&#34;&#34;&#34;
        self.save_gedcom(stdout)

    def save_gedcom(self, open_file: IO, recursive: bool = True):
        &#34;&#34;&#34;Save GEDCOM data to a file.
        &#34;&#34;&#34;
        open_file.write(self.to_gedcom_string(recursive))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gedcom.reader.Reader" href="reader.html#gedcom.reader.Reader">Reader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gedcom.parser.Parser.find_path_to_ancestor"><code class="name flex">
<span>def <span class="ident">find_path_to_ancestor</span></span>(<span>self, descendant: <a title="gedcom.elements.individual.IndividualElement" href="elements/individual.html#gedcom.elements.individual.IndividualElement">IndividualElement</a>, ancestor: <a title="gedcom.elements.individual.IndividualElement" href="elements/individual.html#gedcom.elements.individual.IndividualElement">IndividualElement</a>, path: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return path from descendant to ancestor.
:rtype: object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_path_to_ancestor(self, descendant: IndividualElement,
                          ancestor: IndividualElement, path: str = None):
    &#34;&#34;&#34;Return path from descendant to ancestor.
    :rtype: object
    &#34;&#34;&#34;
    if not isinstance(descendant, IndividualElement) and isinstance(ancestor,
                                                                    IndividualElement):
        raise NotAnActualIndividualError(
            &#34;Operation only valid for elements with %s tag.&#34; % tags.GEDCOM_TAG_INDIVIDUAL
        )

    if not path:
        path = [descendant]

    if path[-1].get_pointer() == ancestor.get_pointer():
        return path

    parents = self.get_parents(descendant, &#34;NAT&#34;)
    for parent in parents:
        potential_path = self.find_path_to_ancestor(parent, ancestor, path + [parent])
        if potential_path is not None:
            return potential_path

    return None</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.get_ancestors"><code class="name flex">
<span>def <span class="ident">get_ancestors</span></span>(<span>self, individual: <a title="gedcom.elements.individual.IndividualElement" href="elements/individual.html#gedcom.elements.individual.IndividualElement">IndividualElement</a>, ancestor_type: str = 'ALL') ‑> List[<a title="gedcom.elements.element.Element" href="elements/element.html#gedcom.elements.element.Element">Element</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return elements corresponding to ancestors of an individual.</p>
<p>Optional argument <code>ancestor_type</code> can be used to return specific subsets:</p>
<p>"ALL": Default, returns all ancestors.</p>
<p>"NAT": Return only natural (genetic) ancestors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ancestors(self, individual: IndividualElement,
                  ancestor_type: str = &#34;ALL&#34;) -&gt; List[Element]:
    &#34;&#34;&#34;Return elements corresponding to ancestors of an individual.

    Optional argument `ancestor_type` can be used to return specific subsets:

    &#34;ALL&#34;: Default, returns all ancestors.

    &#34;NAT&#34;: Return only natural (genetic) ancestors.
    &#34;&#34;&#34;
    if not isinstance(individual, IndividualElement):
        raise NotAnActualIndividualError(
            &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
        )

    parents = self.get_parents(individual, ancestor_type)
    ancestors = []
    ancestors.extend(parents)

    for parent in parents:
        ancestors.extend(self.get_ancestors(parent))

    return ancestors</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.get_element_dictionary"><code class="name flex">
<span>def <span class="ident">get_element_dictionary</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary containing all elements, identified by a pointer,
from within the GEDCOM file.</p>
<p>Only elements identified by a pointer are listed in the dictionary.
The keys for the dictionary are the pointers.</p>
<p>This dictionary gets generated on-the-fly, but gets cached. If the
database was modified, you should call <code>invalidate_cache()</code> once to let
this method return updated data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_dictionary(self) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary containing all elements, identified by a pointer,
    from within the GEDCOM file.

    Only elements identified by a pointer are listed in the dictionary.
    The keys for the dictionary are the pointers.

    This dictionary gets generated on-the-fly, but gets cached. If the
    database was modified, you should call `invalidate_cache()` once to let
    this method return updated data.
    &#34;&#34;&#34;
    if not self.__element_dictionary:
        self.__element_dictionary = {
            element.get_pointer():
            element for element in self.get_root_child_elements() if element.get_pointer()
        }

    return self.__element_dictionary</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.get_element_list"><code class="name flex">
<span>def <span class="ident">get_element_list</span></span>(<span>self) ‑> List[<a title="gedcom.elements.element.Element" href="elements/element.html#gedcom.elements.element.Element">Element</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list containing all elements from within the GEDCOM file.</p>
<p>By default elements are in the same order as they appeared in the file.</p>
<p>This list gets generated on-the-fly, but gets cached. If the database
was modified, you should call <code><a title="gedcom.parser.Parser.invalidate_cache" href="#gedcom.parser.Parser.invalidate_cache">Parser.invalidate_cache()</a></code> once
to let this method return updated data.</p>
<p>Consider using <code><a title="gedcom.parser.Parser.get_root_element" href="#gedcom.parser.Parser.get_root_element">Parser.get_root_element()</a></code> or
<code><a title="gedcom.parser.Parser.get_root_child_elements" href="#gedcom.parser.Parser.get_root_child_elements">Parser.get_root_child_elements()</a></code> to access
the hierarchical GEDCOM tree, unless you rarely modify the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_list(self) -&gt; List[Element]:
    &#34;&#34;&#34;Returns a list containing all elements from within the GEDCOM file.

    By default elements are in the same order as they appeared in the file.

    This list gets generated on-the-fly, but gets cached. If the database
    was modified, you should call `gedcom.parser.Parser.invalidate_cache()` once
    to let this method return updated data.

    Consider using `gedcom.parser.Parser.get_root_element()` or
    `gedcom.parser.Parser.get_root_child_elements()` to access
    the hierarchical GEDCOM tree, unless you rarely modify the database.
    &#34;&#34;&#34;
    if not self.__element_list:
        for element in self.get_root_child_elements():
            self.__build_list(element, self.__element_list)
    return self.__element_list</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.get_families"><code class="name flex">
<span>def <span class="ident">get_families</span></span>(<span>self, individual: <a title="gedcom.elements.individual.IndividualElement" href="elements/individual.html#gedcom.elements.individual.IndividualElement">IndividualElement</a>, family_type: str = 'FAMS') ‑> List[<a title="gedcom.elements.family.FamilyElement" href="elements/family.html#gedcom.elements.family.FamilyElement">FamilyElement</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return family elements listed for an individual.</p>
<p>Optional argument <code>family_type</code> can be used to return specific subsets:</p>
<p><code>tags.GEDCOM_TAG_FAMILY_SPOUSE</code>: Default, families where the individual is a spouse.</p>
<p><code>tags.GEDCOM_TAG_FAMILY_CHILD</code>: Families where the individual is a child.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_families(self, individual: IndividualElement,
                 family_type: str = tags.GEDCOM_TAG_FAMILY_SPOUSE) -&gt; List[FamilyElement]:
    &#34;&#34;&#34;Return family elements listed for an individual.

    Optional argument `family_type` can be used to return specific subsets:

    `tags.GEDCOM_TAG_FAMILY_SPOUSE`: Default, families where the individual is a spouse.

    `tags.GEDCOM_TAG_FAMILY_CHILD`: Families where the individual is a child.
    &#34;&#34;&#34;
    if not isinstance(individual, IndividualElement):
        raise NotAnActualIndividualError(
            &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
        )

    families = []
    element_dictionary = self.get_element_dictionary()

    for child_element in individual.get_child_elements():
        is_family = (child_element.get_tag() == family_type
                     and child_element.get_value() in element_dictionary
                     and element_dictionary[child_element.get_value()].is_family())
        if is_family:
            families.append(element_dictionary[child_element.get_value()])

    return families</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.get_family_members"><code class="name flex">
<span>def <span class="ident">get_family_members</span></span>(<span>self, family: <a title="gedcom.elements.family.FamilyElement" href="elements/family.html#gedcom.elements.family.FamilyElement">FamilyElement</a>, members_type: str = 'ALL') ‑> List[<a title="gedcom.elements.individual.IndividualElement" href="elements/individual.html#gedcom.elements.individual.IndividualElement">IndividualElement</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return array of family members: individual, spouse, and children.</p>
<p>Optional argument <code>members_type</code> can be used to return specific subsets:</p>
<p>"FAMILY_MEMBERS_TYPE_ALL": Default, return all members of the family</p>
<p>"FAMILY_MEMBERS_TYPE_PARENTS": Return individuals with "HUSB" and "WIFE" tags (parents)</p>
<p>"FAMILY_MEMBERS_TYPE_HUSBAND": Return individuals with "HUSB" tags (father)</p>
<p>"FAMILY_MEMBERS_TYPE_WIFE": Return individuals with "WIFE" tags (mother)</p>
<p>"FAMILY_MEMBERS_TYPE_CHILDREN": Return individuals with "CHIL" tags (children)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_family_members(self, family: FamilyElement,
                       members_type: str = FAMILY_MEMBERS_TYPE_ALL) -&gt; List[IndividualElement]:
    &#34;&#34;&#34;Return array of family members: individual, spouse, and children.

    Optional argument `members_type` can be used to return specific subsets:

    &#34;FAMILY_MEMBERS_TYPE_ALL&#34;: Default, return all members of the family

    &#34;FAMILY_MEMBERS_TYPE_PARENTS&#34;: Return individuals with &#34;HUSB&#34; and &#34;WIFE&#34; tags (parents)

    &#34;FAMILY_MEMBERS_TYPE_HUSBAND&#34;: Return individuals with &#34;HUSB&#34; tags (father)

    &#34;FAMILY_MEMBERS_TYPE_WIFE&#34;: Return individuals with &#34;WIFE&#34; tags (mother)

    &#34;FAMILY_MEMBERS_TYPE_CHILDREN&#34;: Return individuals with &#34;CHIL&#34; tags (children)
    &#34;&#34;&#34;
    if not isinstance(family, FamilyElement):
        raise NotAnActualFamilyError(
            &#34;Operation only valid for element with %s tag.&#34; % tags.GEDCOM_TAG_FAMILY
        )

    family_members = []
    element_dictionary = self.get_element_dictionary()

    for child_element in family.get_child_elements():
        # Default is ALL
        is_family = (child_element.get_tag() == tags.GEDCOM_TAG_HUSBAND
                     or child_element.get_tag() == tags.GEDCOM_TAG_WIFE
                     or child_element.get_tag() == tags.GEDCOM_TAG_CHILD)

        if members_type == FAMILY_MEMBERS_TYPE_PARENTS:
            is_family = (child_element.get_tag() == tags.GEDCOM_TAG_HUSBAND
                         or child_element.get_tag() == tags.GEDCOM_TAG_WIFE)
        elif members_type == FAMILY_MEMBERS_TYPE_HUSBAND:
            is_family = child_element.get_tag() == tags.GEDCOM_TAG_HUSBAND
        elif members_type == FAMILY_MEMBERS_TYPE_WIFE:
            is_family = child_element.get_tag() == tags.GEDCOM_TAG_WIFE
        elif members_type == FAMILY_MEMBERS_TYPE_CHILDREN:
            is_family = child_element.get_tag() == tags.GEDCOM_TAG_CHILD

        if is_family and child_element.get_value() in element_dictionary:
            family_members.append(element_dictionary[child_element.get_value()])

    return family_members</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.get_marriage_years"><code class="name flex">
<span>def <span class="ident">get_marriage_years</span></span>(<span>self, individual: <a title="gedcom.elements.individual.IndividualElement" href="elements/individual.html#gedcom.elements.individual.IndividualElement">IndividualElement</a>) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of marriage years for an individual.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_marriage_years(self, individual: IndividualElement) -&gt; List[int]:
    &#34;&#34;&#34;Returns a list of marriage years for an individual.
    &#34;&#34;&#34;
    dates = []

    if not isinstance(individual, IndividualElement):
        raise NotAnActualIndividualError(
            &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
        )

    # Get and analyze families where individual is spouse.
    families = self.get_families(individual, tags.GEDCOM_TAG_FAMILY_SPOUSE)
    for family in families:
        for child in family.get_child_elements():
            if child.get_tag() == tags.GEDCOM_TAG_MARRIAGE:
                for gchild in child.get_child_elements():
                    if gchild.get_tag() == tags.GEDCOM_TAG_DATE:
                        date = gchild.get_value().split()[-1]
                        try:
                            dates.append(int(date))
                        except ValueError:
                            pass
    return dates</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.get_marriages"><code class="name flex">
<span>def <span class="ident">get_marriages</span></span>(<span>self, individual: <a title="gedcom.elements.individual.IndividualElement" href="elements/individual.html#gedcom.elements.individual.IndividualElement">IndividualElement</a>) ‑> Tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of marriages of an individual formatted as a tuple:
(<code>str</code> date, <code>str</code> place)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_marriages(self, individual: IndividualElement) -&gt; Tuple[str, str]:
    &#34;&#34;&#34;Returns a list of marriages of an individual formatted as a tuple:
    (`str` date, `str` place)
    &#34;&#34;&#34;
    marriages = []
    if not isinstance(individual, IndividualElement):
        raise NotAnActualIndividualError(
            &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
        )
    # Get and analyze families where individual is spouse.
    families = self.get_families(individual, tags.GEDCOM_TAG_FAMILY_SPOUSE)
    for family in families:
        for family_data in family.get_child_elements():
            if family_data.get_tag() == tags.GEDCOM_TAG_MARRIAGE:
                date = &#39;&#39;
                place = &#39;&#39;
                for marriage_data in family_data.get_child_elements():
                    if marriage_data.get_tag() == tags.GEDCOM_TAG_DATE:
                        date = marriage_data.get_value()
                    if marriage_data.get_tag() == tags.GEDCOM_TAG_PLACE:
                        place = marriage_data.get_value()
                marriages.append((date, place))
    return marriages</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.get_parents"><code class="name flex">
<span>def <span class="ident">get_parents</span></span>(<span>self, individual: <a title="gedcom.elements.individual.IndividualElement" href="elements/individual.html#gedcom.elements.individual.IndividualElement">IndividualElement</a>, parent_type: str = 'ALL') ‑> List[<a title="gedcom.elements.individual.IndividualElement" href="elements/individual.html#gedcom.elements.individual.IndividualElement">IndividualElement</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return elements corresponding to parents of an individual.</p>
<p>Optional argument <code>parent_type</code> can be used to return specific subsets:</p>
<p>"ALL": Default, returns all parents.</p>
<p>"NAT": Return only natural (genetic) parents.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parents(self, individual: IndividualElement,
                parent_type: str = &#34;ALL&#34;) -&gt; List[IndividualElement]:
    &#34;&#34;&#34;Return elements corresponding to parents of an individual.

    Optional argument `parent_type` can be used to return specific subsets:

    &#34;ALL&#34;: Default, returns all parents.

    &#34;NAT&#34;: Return only natural (genetic) parents.
    &#34;&#34;&#34;
    if not isinstance(individual, IndividualElement):
        raise NotAnActualIndividualError(
            &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
        )

    parents = []
    families = self.get_families(individual, tags.GEDCOM_TAG_FAMILY_CHILD)

    for family in families:
        if parent_type == &#34;NAT&#34;:
            for family_member in family.get_child_elements():

                if family_member.get_tag() == tags.GEDCOM_TAG_CHILD \
                        and family_member.get_value() == individual.get_pointer():

                    for child in family_member.get_child_elements():
                        if child.get_value() == &#34;Natural&#34;:
                            if child.get_tag() == tags.GEDCOM_PROGRAM_DEFINED_TAG_MREL:
                                parents += self.get_family_members(family,
                                                                   tags.GEDCOM_TAG_WIFE)
                            elif child.get_tag() == tags.GEDCOM_PROGRAM_DEFINED_TAG_FREL:
                                parents += self.get_family_members(family,
                                                                   tags.GEDCOM_TAG_HUSBAND)
        else:
            parents += self.get_family_members(family, &#34;PARENTS&#34;)

    return parents</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.get_root_child_elements"><code class="name flex">
<span>def <span class="ident">get_root_child_elements</span></span>(<span>self) ‑> List[<a title="gedcom.elements.element.Element" href="elements/element.html#gedcom.elements.element.Element">Element</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of logical records in the GEDCOM file.</p>
<p>By default, elements are in the same order as they appeared in the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_root_child_elements(self) -&gt; List[Element]:
    &#34;&#34;&#34;Returns a list of logical records in the GEDCOM file.

    By default, elements are in the same order as they appeared in the file.
    &#34;&#34;&#34;
    return self.get_root_element().get_child_elements()</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.get_root_element"><code class="name flex">
<span>def <span class="ident">get_root_element</span></span>(<span>self) ‑> <a title="gedcom.elements.root.RootElement" href="elements/root.html#gedcom.elements.root.RootElement">RootElement</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a virtual root element containing all logical records as children.</p>
<p>When printed, this element converts to an empty string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_root_element(self) -&gt; RootElement:
    &#34;&#34;&#34;Returns a virtual root element containing all logical records as children.

    When printed, this element converts to an empty string.
    &#34;&#34;&#34;
    return self.__root_element</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.invalidate_cache"><code class="name flex">
<span>def <span class="ident">invalidate_cache</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Empties the element list and dictionary to cause
<code><a title="gedcom.parser.Parser.get_element_list" href="#gedcom.parser.Parser.get_element_list">Parser.get_element_list()</a></code> and
<code><a title="gedcom.parser.Parser.get_element_dictionary" href="#gedcom.parser.Parser.get_element_dictionary">Parser.get_element_dictionary()</a></code> to return updated data.</p>
<p>The update gets deferred until each of the methods actually gets called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invalidate_cache(self):
    &#34;&#34;&#34;Empties the element list and dictionary to cause
    `gedcom.parser.Parser.get_element_list()` and
    `gedcom.parser.Parser.get_element_dictionary()` to return updated data.

    The update gets deferred until each of the methods actually gets called.
    &#34;&#34;&#34;
    self.__element_list = []
    self.__element_dictionary = {}</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.marriage_range_match"><code class="name flex">
<span>def <span class="ident">marriage_range_match</span></span>(<span>self, individual: <a title="gedcom.elements.individual.IndividualElement" href="elements/individual.html#gedcom.elements.individual.IndividualElement">IndividualElement</a>, from_year: int, to_year: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if one of the marriage years of an individual is in a given range.
Years are integers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def marriage_range_match(self, individual: IndividualElement,
                         from_year: int, to_year: int) -&gt; bool:
    &#34;&#34;&#34;Check if one of the marriage years of an individual is in a given range.
    Years are integers.
    &#34;&#34;&#34;
    if not isinstance(individual, IndividualElement):
        raise NotAnActualIndividualError(
            &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
        )

    years = self.get_marriage_years(individual)
    for year in years:
        if from_year &lt;= year &lt;= to_year:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.marriage_year_match"><code class="name flex">
<span>def <span class="ident">marriage_year_match</span></span>(<span>self, individual: <a title="gedcom.elements.individual.IndividualElement" href="elements/individual.html#gedcom.elements.individual.IndividualElement">IndividualElement</a>, year: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if one of the marriage years of an individual matches the supplied year.
Year is an integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def marriage_year_match(self, individual: IndividualElement, year: int) -&gt; bool:
    &#34;&#34;&#34;Checks if one of the marriage years of an individual matches the supplied year.
    Year is an integer.
    &#34;&#34;&#34;
    if not isinstance(individual, IndividualElement):
        raise NotAnActualIndividualError(
            &#34;Operation only valid for elements with %s tag&#34; % tags.GEDCOM_TAG_INDIVIDUAL
        )

    years = self.get_marriage_years(individual)
    return year in years</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, gedcom_stream: IO, strict: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a stream, or an array of lines, as GEDCOM formatted data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, gedcom_stream: IO, strict: bool = True):
    &#34;&#34;&#34;Parses a stream, or an array of lines, as GEDCOM formatted data.
    &#34;&#34;&#34;
    self.invalidate_cache()
    self.__root_element = RootElement()

    line_number = 1
    last_element = self.get_root_element()

    for line in gedcom_stream:
        last_element = self.__parse_line(line_number, line, last_element, strict)
        line_number += 1</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.parse_file"><code class="name flex">
<span>def <span class="ident">parse_file</span></span>(<span>self, file_path: str, strict: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens and parses a file, from the given file path, as GEDCOM formatted data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_file(self, file_path: str, strict: bool = True):
    &#34;&#34;&#34;Opens and parses a file, from the given file path, as GEDCOM formatted data.
    &#34;&#34;&#34;
    codec = get_encoding(file_path)
    real_version, reported_version, reported_format = get_version(file_path, codec)

    if reported_version == &#39;5.5.5&#39;:
        errmsg = &#34;This parser does not properly support the GEDCOM &#34; + reported_version + \
            &#34; standard at this time\nSee: {0}&#34;.format(standards.GEDCOM_5_5_5)
        raise GedcomVersionUnsupportedError(errmsg)

    if reported_format not in [&#39;LINEAGE-LINKED&#39;, &#39;LINEAGE_LINKED&#39;,
                               &#39;LINAGE-LINKED&#39;, &#39;Lineage - Linked&#39;]:
        errmsg = &#34;This parser does not recognize the GEDCOM format &#34; + reported_format + \
            &#34; at this time\nSee: {0}&#34;.format(standards.GEDCOM_5_5_5)
        raise GedcomFormatUnsupportedError(errmsg)

    with open(file_path, &#39;r&#39;, encoding=codec) as gedcom_stream:
        self.parse(gedcom_stream, strict)</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.print_gedcom"><code class="name flex">
<span>def <span class="ident">print_gedcom</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Write GEDCOM data to stdout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_gedcom(self):
    &#34;&#34;&#34;Write GEDCOM data to stdout.&#34;&#34;&#34;
    self.save_gedcom(stdout)</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.save_gedcom"><code class="name flex">
<span>def <span class="ident">save_gedcom</span></span>(<span>self, open_file: IO, recursive: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save GEDCOM data to a file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_gedcom(self, open_file: IO, recursive: bool = True):
    &#34;&#34;&#34;Save GEDCOM data to a file.
    &#34;&#34;&#34;
    open_file.write(self.to_gedcom_string(recursive))</code></pre>
</details>
</dd>
<dt id="gedcom.parser.Parser.to_gedcom_string"><code class="name flex">
<span>def <span class="ident">to_gedcom_string</span></span>(<span>self, recursive: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Formats all elements and optionally all of the sub-elements into a
GEDCOM string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_gedcom_string(self, recursive: bool = False) -&gt; str:
    &#34;&#34;&#34;Formats all elements and optionally all of the sub-elements into a
    GEDCOM string.
    &#34;&#34;&#34;
    is_gte_python_3 = version_info[0] &gt;= 3
    output = &#39;&#39; if is_gte_python_3 else b&#39;&#39;

    for element in self.get_root_child_elements():
        if is_gte_python_3:
            output += element.to_gedcom_string(recursive)
        else:
            output += element.to_gedcom_string(recursive).encode(&#39;utf-8-sig&#39;)

    return output</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gedcom" href="index.html">gedcom</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gedcom.parser.Parser" href="#gedcom.parser.Parser">Parser</a></code></h4>
<ul class="">
<li><code><a title="gedcom.parser.Parser.find_path_to_ancestor" href="#gedcom.parser.Parser.find_path_to_ancestor">find_path_to_ancestor</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_ancestors" href="#gedcom.parser.Parser.get_ancestors">get_ancestors</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_element_dictionary" href="#gedcom.parser.Parser.get_element_dictionary">get_element_dictionary</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_element_list" href="#gedcom.parser.Parser.get_element_list">get_element_list</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_families" href="#gedcom.parser.Parser.get_families">get_families</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_family_members" href="#gedcom.parser.Parser.get_family_members">get_family_members</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_marriage_years" href="#gedcom.parser.Parser.get_marriage_years">get_marriage_years</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_marriages" href="#gedcom.parser.Parser.get_marriages">get_marriages</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_parents" href="#gedcom.parser.Parser.get_parents">get_parents</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_root_child_elements" href="#gedcom.parser.Parser.get_root_child_elements">get_root_child_elements</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_root_element" href="#gedcom.parser.Parser.get_root_element">get_root_element</a></code></li>
<li><code><a title="gedcom.parser.Parser.invalidate_cache" href="#gedcom.parser.Parser.invalidate_cache">invalidate_cache</a></code></li>
<li><code><a title="gedcom.parser.Parser.marriage_range_match" href="#gedcom.parser.Parser.marriage_range_match">marriage_range_match</a></code></li>
<li><code><a title="gedcom.parser.Parser.marriage_year_match" href="#gedcom.parser.Parser.marriage_year_match">marriage_year_match</a></code></li>
<li><code><a title="gedcom.parser.Parser.parse" href="#gedcom.parser.Parser.parse">parse</a></code></li>
<li><code><a title="gedcom.parser.Parser.parse_file" href="#gedcom.parser.Parser.parse_file">parse_file</a></code></li>
<li><code><a title="gedcom.parser.Parser.print_gedcom" href="#gedcom.parser.Parser.print_gedcom">print_gedcom</a></code></li>
<li><code><a title="gedcom.parser.Parser.save_gedcom" href="#gedcom.parser.Parser.save_gedcom">save_gedcom</a></code></li>
<li><code><a title="gedcom.parser.Parser.to_gedcom_string" href="#gedcom.parser.Parser.to_gedcom_string">to_gedcom_string</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>